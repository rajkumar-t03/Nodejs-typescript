Introduction
In this series, we will be learning how to create our own RESTful API in Node.js using an excellent web framework named Express. However, before we start, a little theory:

REST stands for Representational State Transfer. An awesome style of software architecture designed by Roy Fielding for his doctoral dissertation. REST allows us to design loosely coupled applications by using the HTTP protocol.

HTTP provides us with the following verbs, or methods: GET, POST, PUT and DELETE, which correspond to Read, Create, Update and Delete (CRUD operations) respectively. There are a few other verbs, but they aren’t used as frequently. We will be using these verbs to make requests, which will perform various operations on our data.

Since (in my humble opinion) TypeScript is the best thing since sliced bread, this is the language that we will be using. For those unfamiliar with it, TypeScript is a typed superset of JavaScript that we compile to plain ol’ JavaScript, and, among many other things, allows us to add types to JavaScript.

Since we need a database to store our data, we will be using a dockerized instance of MongoDB, together with Mongoose, an ODM which makes interacting with MongoDB that much easier.

Now that we know what and how we will be working on, let’s start coding.

The pre-requisites
Preview
Before we start, I’d like to show you a preview of how our directory tree will look by the end of this series:


pokeApi part1 directory tree
In case anyone is curious about how I generated the directory tree image, I used the Linux tree command and snapped a screenshot of my terminal.

Installing Node.js
Since we will be using Node.js for our project, the first thing to do is make sure it is installed on our machine.

Tip: Open up your terminal and run this command to check if Node is installed: node -v.

If not, you can install it here.

Installing Docker and Docker-compose
Docker is a fantastic tool that allows us to create, deploy and run applications (or pretty much anything we want) by using containers. We can deploy a MongoDB database (or any other database, you name it) in a few minutes, with a couple of simple commands.

Tip: Run docker -v to see if you have Docker on your machine.

If not, you can install it here.

As I’ve just mentioned, Docker is awesome. However, and this is purely personal taste, I prefer to deploy my containers using Docker Compose, which is a neat tool offered by Docker. It allows us to create a .yml configuration file, where we can specify all the details of our container, and deploy said container with one simple command.

Tip: Run docker-compose -v to check if you have Docker-Compose on your machine.

If not, you can install it here.

The setup
Getting started
With all our pre-requisites out of the way, we can now start coding for real. Let’s begin:

The first step is to create the file where our project is going to live. I’m going to name our project directory pokeApi. Feel free to choose a different name if you like, it’s entirely up to you. To create and enter our project directory, open up your terminal and type the following commands:

mkdir pokeApi
cd pokeApi
Once inside our project file, we want to create our package.json file. To do so, type the following command in your terminal:

npm init
After running this command, we will be asked a series of questions, and, upon answering them, our package.json file will be created.

Tip: If you don’t feel like answering npm’s questions, use this command instead: npm init -y.
You can always go back to the package.json file and edit it later.

Installing dependencies
To be able to use express, mongoose, TypeScript etc. we must install a few dependencies. To do so, run the following command:

npm i body-parser cors express mongoose
We also need to install several dependencies needed only for development:

npm i -D @types/body-parser @types/cors @types/express @types/mongoose @types/node nodemon ts-node typescript
Tip: By adding -D or --save-dev to npm i command, the dependencies installed will be listed under devDependencies in the package.json file.

Adding npm scripts
To be able to run our project, we must create the following script in our package.json file:

"scripts": {
"start": "nodemon"
},
Configuring nodemon
Nodemon is a neat tool for developing Node.js applications. It automatically restarts the application whenever it detects changes in the code. (Which is basically, whenever we save.)

Create a file named nodemon.json, and add the following:

{
"watch": ["src"],
"ext": "ts",
"exec": "ts-node ./src/server.ts"
}
This tells nodemon which files to watch and execute.

Configuring TypeScript
To generate our tsconfig.json file, run the following command:

tsc --init
Note that the tsconfig.json file generated by default contains many, many configuration options, many of which we probably won’t need to use. You may, of course, configure TypeScript according to your preferences. If not, here’s the configuration I use:


Creating a .gitignore file
In this file, we can list all the files/directories that we want git to ignore. This means that when we add and commit the changes made to our project, these files will remain “invisible” to git.

Tip: It is very, very, very important to add node_modules to our .gitignore. We most definitely don’t want this huge file pushed to our repository!

To create our .gitignore file, run the following command, while in the root of the directory:

touch .gitignore
Then, add the following lines inside the file:

node_modules
dist
Let the coding begin
Setting up our server
The first thing we are going to do is create our basic directory structure. We are going to create a directory named src, which will contain all of our project files, aside from config:

mkdir src
cd src 
mkdir constants
touch server.ts
touch app.ts 
Let us open the app.ts file we just created, which will contain our express configuration. This may seem like a lot of code all at once, but don’t worry! It’s just the basic configuration that express needs to work, and we’ll go over every single line so that we understand what’s going on:


https://gist.github.com/NyaGarcia/a2050d0366fc1dff5d6ed053ba084e2a
Let’s go over Express’ config quickly:

Body parser allows us to receive requests with data in different formats, such as json, or x-www-form-urlencoded.
CORS (Cross-Origin Resource Sharing) uses additional HTTP headers which let our browser know that it has to allow a web application running at one domain to access resources from a server at a different origin.
Once this is done, we’re going to create a file to store our app’s constants. Why? Because this way we only have to declare each constant once. Whenever we need to make use of it, we just have to import it.

Furthermore, if we need to change the value of our constant (yes, even though it’s a constant, the time may come when we need to change its value), it will change everywhere in our project, since it’s only declared in one place. All of this said, let’s create our constants file:

cd constants
touch pokeApi.constants.ts
The first constant we are going to declare is our PORT, which will store the number of the port we are going to open for our server:

//src/constants/pokeApi.constants.ts
export const PORT = 9001;
Now, head over to our server.ts file, where we will set up our server:


https://gist.github.com/NyaGarcia/abd9f3b020e74a9284437cef38daadb2
Tip: If anyone is unfamiliar with the syntax I’m using in the console.log, it’s a technique named template literals. You type everything inside grave quotes (``), and use interpolation (${}) to embed variables. More about this technique here.

Note that we are importing both the app we created previously, and our PORT constant.

And with just these three lil’ files, we’ve created our very own server! Fire up your terminal and execute the npm start script we created previously. You can do this by typing:

npm run start (or just npm start for the pros)
Tip: Since we are using nodemon to watch our project files, we only need to execute the previous command once. Every time we save our changes, nodemon will automatically restart our app for us.

After executing the command, you should see the Listening on port 9001 message on your terminal. Awesome! We now have our server up and running.

You can also head over to your favorite browser to check it out:

localhost:9001
You should see a message similar to this: Cannot GET /. I know, not very exciting… But if you’re seeing this message, it works! If not, go back and re-check your code to make sure nothing is missing.

Creating our first GET route
Since we now have our server up and running, we are going to create the first GET route and display a nice welcome message. After all, ‘Cannot GET /’ isn’t exactly welcoming.

To do this, we need to create a file named pokemon.controller.ts (in src), which will have a public router property. This property will hold an instance of the Express router, which we will use to define our routes. Here’s what our controller should initially look like:



Our Pokemon controller is where we’re going to define all of the Pokemon routes. Each route will perform a different action, like for example:

Getting a list of all the available Pokemon in the database.
Adding a new Pokemon.
Updating a Pokemon.
Deleting a Pokemon.
Anything else we want to do.
The first route that we are going to define is a simple GET route, which will return a nice welcome message. To do so, we need to create a setRoutes method, which will be responsible for defining the routes. Inside it, we can then define our first GET route, like so:


Tip: Don’t forget to call the setRoutes method in the controller, or the routes won’t work!

As you can see in the previous code, we’ve used the Express router to define a GET route, which receives two parameters:

The first is the path we’ll use to access our route, which we’ve defined as /.
The second is a callback function, which in turn receives two parameters (it can receive an optional third parameter, next, which we will use later on in our other routes): the Request and Response objects. The Request object, as its name indicates, represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers etc. On the other hand, the Response object represents the HTTP response that our app will send out to answer any received HTTP requests.
Therefore, by using the Response object we can send out our welcome message. Simple, isn’t it? However, there is something that is slightly off about our route…

The separation of concerns
The main goal that developers should have is to write clean, maintainable code. Why? Because

Our code should not depend on concrete implementations. What does this mean exactly? Allow to me to illustrate with an example:

For this project, we are, initially, going to use a MongoDB database. However, let’s suppose that we are required to change the database to MySQL. Since all of the functions that interact with the database are defined inside the controller, alongside the routes, to make the change to a MySQL database we would have to go to our controller, and modify every single function.

However, if we define all of the MongoDB database functions in a separate file, a file named PokemonService that implements a generic , if we wanted to change to MySQL, all we would have to do is create another service, this time with a MySQL specific implementation of the generic interface, and inject said service into our controller, substituting the MongoDB service.

In a nutshell, by using a service to interact with our database, we keep our code loosely coupled, ergo maintainable.

Creating the Pokemon service
Therefore, we will now create a directory named services, and inside it, we’ll create a file named pokemon.service.ts. Once we’ve done that, we’ll add the following code:


PokemonService version 1
A very simple function, which returns our cute welcome message. Now, we need to head over to our pokemon.controller and do two things:

Import the service we have just created.
Call the service’s getWelcomeMessage function from our main GET route.

PokemonController version 3 https://gist.github.com/NyaGarcia/b2d5acfc9181f34b064291d9633dea76
As you can see, our main route now calls the getWelcomeMessage function that we have just created in our PokemonService, and sends it out by using the Response object.

So far, so good. It’s time to import our Controller into our app.ts:


As you can see on line 28, we’re once again making use of the app.use method, which receives an optional path argument as well as the middleware callback function. Basically, what we’re doing here is telling Express to invoke the PokemonController router whenever we make a request that begins with /pokemon.

And we’re done! Head over to your browser, and if you’ve done everything correctly, you should see your welcome message displayed, like this:


Welcome message
It’s time to refactor
Removing hard coded strings
Remember we created a file which would store all of our constants? You may have realized that in our welcomeMessage function (in our pokemon service), we were returning a String containing the message, which we hard coded into our service. Not very neat, right? What if we want to change the message? We’d have to modify the service, which isn’t something we want.

Therefore, we are going to take the welcome message and declare it in our constants file:



One we’ve done this, we need to import the constants file in our service, like so:

If you go back to your browser, you should still see the welcome message.

Extracting callback functions
Another thing we can do to clean up our code a little is to extract the anonymous callback functions into named functions. Let’s take a look at how to do that:


As you can see, by extracting the callback logic into the sayHello function, our route looks a lot cleaner. You can now see the two parameters it receives, the route and the callback functions, at a glance.

>>>
In the previous post, we set up our server and implemented our first GET route, which returned a lovely welcome message. As our goal is to perform basic CRUD operations on our Pokemon data, we need to have a database to store our information.

In this post, we are going to create and deploy a Docker container for our MongoDB database. We are also going to define our Pokemon data model using Mongoose.

Let’s Code
Preview
Once again, before we start, a little preview of how our directory tree will look by the end of this post:


PokeAPI part 2 directory tree
Just as a reminder: to run our project we’re currently using the following command:

npm run start
This said, let us begin.

Creating Our Docker-Compose File
The first thing we are going to do is create a docker-compose.yml file, on the same level as our src directory, which is to say, outside of the src directory.

Once this is done, copy and paste the following code into the newly created file:


docker-compose.yml file
I’ll briefly explain what these configuration options mean:

version: Specifies the docker-compose version we are going to use.
services: We can specify a list of services which will be deployed with our container. In our case, we want a database, which is why we use the following attribute:
db: We indicate that we are going to deploy a database.
container_name: This is optional. It allows us to specify a custom container name. If we omit this option, a default container name will be generated.
image: Specifies the image that the container will be built from. In our case, the latest MongoDB image.
restart: Always restart the container if it stops. If it is manually stopped, it is restarted only when Docker daemon restarts or the container itself is manually restarted.
volumes: This is a very interesting option. It allows us to have data persistence. What does this mean? All of our data is going to be stored in a Docker container. However, Docker containers can be stopped, restarted, etc. In such cases, what happens to our data? Does it disappear? The answer is, it won’t disappear if we use the volumes option. We can specify a directory on our local machine where our data will be stored. In our case, this directory is named pokeData.
environment: We can specify environment variables. In our case, we are creating a database named Pokemon when the container starts.
ports: Specifies the ports that will be exposed (Host port: Container port). In our case, we are mapping our local port 27017 to the container port 27017 (27017 is the default port for MongoDB).
Tip: For more information about docker-compose files, you can check out this link.

Now that we have our docker-compose file ready, let’s start the container. Fire up your terminal, and type the following command to deploy:

docker-compose up 
If you’ve done everything correctly, you should be seeing output similar to this on your terminal:


docker-compose output
You should also see that a new directory named pokeData has appeared in your directory tree. This is the directory we specified earlier in our docker-compose file, by using the “volumes” attribute.

Our pokeData directory will be in charge of storing all our database data (once we insert some), and keeping it safe and sound.

Isn’t Docker awesome and easy to use? A simple, intuitive, extensively documented configuration file and one command are all we need to have our database instance up and running. Beautiful.

Troubleshooting
If you’re getting the following output after executing the docker-compose up command:

ERROR: Couldn’t connect to Docker daemon at http+docker://localhost — is it running?
It means that your Docker daemon isn’t running. Run this command to start the Docker daemon:

sudo systemctl start docker
And try the docker-compose up command again. The error should be gone.

Connecting Our App to Our Dockerized MongoDB Database
We have our database container deployed and running, so we now need to connect our application to it. To do so, we need to create a setMongoConfig method in our app.ts file, which will be responsible for configuring and connecting to the Mongo database. Here’s what this method should look like:


setMongoConfig method in app.ts
You may have noticed that, once again, we are hard-coding a variable: the Mongoose connection string. To avoid this, let’s open our pokeapi.constants file, and store it there:


pokeapi.constants version 2
Back in our app.ts, we can now change the hard-coded string for our newly defined constant:


PokemonController version 5
If we’ve done everything correctly, we should now be seeing the output shown below in the terminal where we ran our docker-compose up command. If, for any reason, you stopped docker-compose previously, run the command again.


docker-compose terminal output
As you can see, our Docker container has accepted the connection we made from our application. So far, so good.

Creating Our Data Model
Now that we are connected to our database, we need a way to interact with it. To achieve this, we are going to use Mongoose, which provides us with several data modeling tools, such as schemas and models. Mongoose makes interacting with MongoDB exceedingly easy and simple.

“Models are fancy constructors compiled from schema definitions. An instance of a model is called a document. Models are responsible for creating and reading documents from the underlying MongoDB database.” — Mongoose documentation

However, before we create our model, we are first going to create an interface, which will allow us to type our model.

Creating the Pokemon interface
We’ll begin by creating an interfaces directory in src, and a pokemon.interface.ts file. Inside the file, we’ll define our Pokemon interface, which needs to extend the mongoose Document:


IPokemon interface
As you can see, the code is quite simple. All we’ve done is define the properties, and their types, that we want our model to have. Once we’ve created the model, we will make use of this interface to type it.

Creating the Pokemon schema and model
To store our data models, we are going to create a models directory in src, which will contain a file named pokemon.model.ts. Inside this file, we’re going to import Mongoose and create a PokemonSchema, which we’ll then use to create our data model. Here’s what our schema will look like:


PokemonSchema
As you can see, as well as defining the properties that our model will have, we’ve defined their types and specified that they are all required. We’ve also added a generic ‘Field is required’ error message, that will be shown if we attempt to create a model that’s missing any of the properties.

Now that we’ve created our Pokemon schema, we need to use it to create a Mongoose model. Therefore, in the same file:


Exporting the Pokemon model
In the above code, we’re creating a Mongoose model using the PokemonSchema, and we’ve typed it using the IPokemon interface we created earlier.

Note: I am fully aware of the fact that we are defining both our schema and model in the same file, a file named pokemon.model. I believe that having two separate files - one for the schema and one for the model - is a little too much, since we can create the model in a single line of code. You may, of course, create a separate file for your schema if you want.

With our Pokemon model just created, it is now time to import it in the PokemonService:


PokemonService version 3
The Pokemon model will later be used to query our MongoDB database, once we create the CRUD routes and their respective db query functions.
>>>
PokemonService: querying the database
It is now time to create our database query functions. To do this, as previously mentioned, we are going to make use of our Pokemon Model.

As our goal is to implement the four basic CRUD operations, the first function we are going to implement is one for reading the contents of the db. So, let’s open up the pokemon.service.ts file, and add a findAll method:


PokemonService version 4 — Creating a new findAll method
As you can see, our new findAll method uses the Pokemon Model to interact with MongoDB and find all the Pokemon in the db. As Mongoose’s helper functions are extensively documented in the Mongoose docs, I don’t think it’s necessary to break them down here.

I will, however, comment on the exec function. As I mentioned earlier, we are going to use Mongoose’s promise based API, and we are going to do so by using the exec function, which returns a Promise.

Implementing GET Routing
We now have our findAll function in our PokemonService. To be able to interact with this function, we must create another GET route in our controller:


PokemonController version 6 — Creating a new get route
The code is pretty simple, we’ve created a new GET route and a new private findAll method, which basically makes a call to the service’s findAll method and sends the response. We are, of course, handling any errors that may occur by wrapping the code in a try/catch block.

Notice the res.status(500) on line 27? Since by default Express sets the Response status property to 200, we need to specify an error status code whenever an error occurs, or we’ll be in danger of obtaining a response that informs us of an error, but that looks fine, with a 200 OK status! We most certainly don’t want that to happen, so, if any errors are caught, we’re sending out a status code of 500, which stands for Internal Server Error, indicating that something went wrong.

Note: I’m aware that sending out a generic 500 status code for ever error isn’t a good practice. In the next part of this series, we’ll implement a better error handling mechanism, with custom errors, centralized error handling and proper status codes.

Testing the route
Now that we’ve defined out new route, it’s time to test it!

Tip: From here on, I recommend using Postman to test our routes.

As you can see, the endpoint to access this new route is /all. Considering that all of our pokemon endpoints start with /pokemon, the complete path would be /pokemon/all.

If all goes well, you should obtain output like the following from Postman:


Postman: Getting all Pokemon
Since we haven’t introduced any data into our db, we are receiving an empty array. We have now completed our first db query successfully!

Adding a New Pokemon
Let’s implement a function to add a new Pokemon to our db. Let’s go back to the PokemonService and create an add method:


PokemonService version 5 —Creating a new add method
To explain briefly, we create a Mongoose Document (newPokemon) from the request body and we save it into the db.

Note: Mongoose Documents are instances of Mongoose Models.

Let’s create the route to interact with our new function. In our controller:


PokemonController version 7 — Adding a new post route
Considering that both the GET and POST routes have exactly the same endpoint, we can chain them as shown above. This way, we don’t have to declare the same route twice, once for each verb.

Note that, this time, our new route is accessed through a POST request. Let’s head over to Postman, and add a new Pokemon to the db:


Postman: Adding a new Pokemon
If everything goes well, you should receive the Pokemon you just added as output. To double-check that our Charmander was added correctly, we can make use of our previous GET route to obtain all of the Pokemon:


Postman: Getting all Pokemon
Congratulations, we now have a Charmander in our db.

Don’t worry about the _id and __v fields. They are generated automatically by Mongoose, and we will talk about them later.

Deleting a Pokemon
It’s now time to implement a function to delete a Pokemon, so let’s open up the PokemonService, and create a delete method:


PokemonService version 6 — Adding a new delete method
Mongoose has a very useful findByIdAndDelete helper function, which allows us to delete a Document (in our case, a Pokemon) by its _id field.

This function is shorthand for findOneAndDelete({_id: pokemonId}).

Note: If you have the need of deleting a document by any field other than _id, you may use the findOneAndDelete function mentioned before. More information about it here.

Guard Clauses
If you’re already familiar with guard clauses, feel free to skip this section. For those of you who aren’t, stay with me and we’ll talk about this very useful technique.

Guard clauses are, put simply, a check that exits the function, either with a return statement or an exception, in case of an error or fulfilled condition. They allow us to avoid unnecessary complexity (if else if structures) in our code. This is our guard clause:


Guard clause
By reversing the logic, and checking whether the Pokemon has been deleted or not, we can avoid an else statement. If the condition is fulfilled, we exit the function by throwing an error. If the Pokemon has been deleted successfully, then the deleted Pokemon result is returned. Simple and elegant.

Defining the DELETE route
Now that we’ve created our delete function, it’s time to create our route. Therefore, in our controller:


PokemonController version 7 — Adding a new delete method
In the DELETE route we have just created, we’re indicating that we’ll receive a request parameter in the URL, a parameter we have named id. We then obtain this parameter on line 46, accessing it via req.params, and passing it to our service.

The path to access our route would look something like this:

localhost:9001/pokemon/123pokemonId
Where 123pokemonId is the id parameter.

Once again, we open Postman, and test our new route by deleting the Pokemon (or whichever Pokemon you chose) we added to our db earlier:


Postman: Deleting a Pokemon
As you can see, we receive the Pokemon that we’ve just deleted. If no Pokemon with the ID we specified were found in the database, we would receive a Pokemon with id '' not found message instead. Let’s attempt to delete the same Pokemon again, and see if we do indeed receive such a message:


Postman: Attempting to delete a Pokemon that doesn’t exist
Lovely, we’re now sure that our error handling works just fine.

We can double check that our Charmander has been deleted correctly by obtaining all Pokemon from the db:


Postman: Getting all Pokemon
Empty array = no Pokemon = Charmander has been deleted successfully.

Updating a Pokemon
In our Pokemon Service:


PokemonService version 7 — Adding an update method
You may note that our new update method is very similar to our delete one. We store the result of the Mongoose query, then use a guard clause to throw an error in case the the Pokemon wasn’t found. If the Pokemon was updated successfully, we return it.

In our controller, let’s create the final route:


PokemonController version 9 — Adding a new put route
Note that once again, we’re chaining our PUT and DELETE routes, since they both share the same endpoint.

Let’s head over to Postman, and test our final route. Don’t forget to add a new Pokemon, or you won’t have any data to update! I chose to add another Charmander, which I will now update:


Postman: Updating a Pokemon
Let’s obtain all our Pokemon to check on our Charmander:


Postman: Getting all Pokemon
Congratulations! Our Charmander has evolved into a Charmeleon, and we’ve successfully implemented all the basic CRUD functions and their respective routes.

Dealing with _id and __v
Last but not least, we’ll deal with the _id and __v fields. These are two fields that are generated automatically by Mongoose. Let’s take a look at what they each represent, and what we can do about them:

Version key: __v is a version key that Mongoose automatically adds to each document. This version key is updated whenever we perform an operation that makes a modification to an array that can potentially change the position of any of the array’s elements. It’s therefore an important field, and unless we know what we’re doing, we shouldn’t disable it. If we dislike the name, we can always change it, by adding a simple line to our Schema:

Customizing the versionKey
Should we want to disable it, and once again, I remind you that you should only do this if you know what you’re doing, we can set the versionKey property to false, like so:


Disabling the versionKey
Note: There is an excellent post by Aaron Heckmann that deals with versionKey in depth. You can read it here.

Mongoose ID: By default, Mongoose adds an _id property to our Schemas. Then, whenever we create a model from a Schema, Mongoose automatically creates a new _id of type ObjectId. Since _id is the unique identifier that Mongoose uses, we can’t get rid of it. What we can do is rename it to id whenever we send out our models to our client, because let’s be honest here, _id does not look as good. To rename it, all we have to do is add the following code to our setMongoConfig method in our app.ts file:

Renaming _id to id
Let’s get back to Postman and check it _id has indeed been renamed to id:


Postman: Getting all Pokemon
We no longer have an ugly _id field.
